-- 1. Fix Transactions Table (Add status column)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'transactions' AND column_name = 'status') THEN
        ALTER TABLE public.transactions ADD COLUMN status text DEFAULT 'completed';
    END IF;
END $$;

-- 2. Fix Reports Table Relationship
-- We need reporter_id to reference public.profiles for easier joining
DO $$
BEGIN
    -- Check if constraint exists and references auth.users
    -- We can just drop and recreate it to be safe
    ALTER TABLE public.reports DROP CONSTRAINT IF EXISTS reports_reporter_id_fkey;
    
    -- Add constraint referencing profiles
    ALTER TABLE public.reports 
    ADD CONSTRAINT reports_reporter_id_fkey 
    FOREIGN KEY (reporter_id) 
    REFERENCES public.profiles(id)
    ON DELETE CASCADE;
END $$;

-- 3. Ensure Collections Tables Exist
CREATE TABLE IF NOT EXISTS public.collections (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  is_public BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE public.collections ENABLE ROW LEVEL SECURITY;

-- Re-apply policies for collections
DROP POLICY IF EXISTS "Collections are viewable by everyone if public" ON public.collections;
CREATE POLICY "Collections are viewable by everyone if public" 
ON public.collections FOR SELECT 
USING (is_public = true OR auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can create collections" ON public.collections;
CREATE POLICY "Users can create collections" 
ON public.collections FOR INSERT 
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own collections" ON public.collections;
CREATE POLICY "Users can update their own collections" 
ON public.collections FOR UPDATE 
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own collections" ON public.collections;
CREATE POLICY "Users can delete their own collections" 
ON public.collections FOR DELETE 
USING (auth.uid() = user_id);

-- Collection Items
CREATE TABLE IF NOT EXISTS public.collection_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  collection_id BIGINT REFERENCES public.collections(id) ON DELETE CASCADE NOT NULL,
  video_id UUID REFERENCES public.videos(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(collection_id, video_id)
);

ALTER TABLE public.collection_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Collection items are viewable by everyone" ON public.collection_items;
CREATE POLICY "Collection items are viewable by everyone" 
ON public.collection_items FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.collections 
    WHERE collections.id = collection_items.collection_id 
    AND (collections.is_public = true OR collections.user_id = auth.uid())
  )
);

DROP POLICY IF EXISTS "Users can add items to their collections" ON public.collection_items;
CREATE POLICY "Users can add items to their collections" 
ON public.collection_items FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.collections 
    WHERE collections.id = collection_items.collection_id 
    AND collections.user_id = auth.uid()
  )
);

DROP POLICY IF EXISTS "Users can remove items from their collections" ON public.collection_items;
CREATE POLICY "Users can remove items from their collections" 
ON public.collection_items FOR DELETE 
USING (
  EXISTS (
    SELECT 1 FROM public.collections 
    WHERE collections.id = collection_items.collection_id 
    AND collections.user_id = auth.uid()
  )
);

-- 4. Ensure Follows Table Exists
CREATE TABLE IF NOT EXISTS public.follows (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  follower_id uuid REFERENCES public.profiles(id) NOT NULL,
  following_id uuid REFERENCES public.profiles(id) NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  UNIQUE(follower_id, following_id)
);

ALTER TABLE public.follows ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Follows are viewable by everyone" ON public.follows;
CREATE POLICY "Follows are viewable by everyone" ON public.follows FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can follow others" ON public.follows;
CREATE POLICY "Users can follow others" ON public.follows FOR INSERT WITH CHECK (auth.uid() = follower_id);

DROP POLICY IF EXISTS "Users can unfollow" ON public.follows;
CREATE POLICY "Users can unfollow" ON public.follows FOR DELETE USING (auth.uid() = follower_id);

-- 5. Ensure Cart Items Table Exists
CREATE TABLE IF NOT EXISTS public.cart_items (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid REFERENCES public.profiles(id) NOT NULL,
    video_id uuid REFERENCES public.videos(id) NOT NULL,
    license_type text DEFAULT 'personal',
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, video_id) -- Prevent duplicates
);

ALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can manage their own cart" ON public.cart_items;
CREATE POLICY "Users can manage their own cart" 
ON public.cart_items 
USING (auth.uid() = user_id);

-- 6. Ensure User Downloads Table Exists
CREATE TABLE IF NOT EXISTS public.user_downloads (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    video_id UUID REFERENCES public.videos(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE public.user_downloads ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own downloads" ON public.user_downloads;
CREATE POLICY "Users can view own downloads"
ON public.user_downloads FOR SELECT
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own downloads" ON public.user_downloads;
CREATE POLICY "Users can insert own downloads"
ON public.user_downloads FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- 7. Create increment_downloads Function (UUID version)
-- Drop the BIGINT version if it exists to avoid confusion
DROP FUNCTION IF EXISTS public.increment_downloads(BIGINT);

CREATE OR REPLACE FUNCTION public.increment_downloads(video_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE public.videos
  SET downloads = COALESCE(downloads, 0) + 1
  WHERE id = video_id;
END;
$$;
